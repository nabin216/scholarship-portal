"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/scholarships/search/page",{

/***/ "(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx":
/*!********************************************************!*\
  !*** ./src/app/Authentication/context/AuthContext.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check if the user is already authenticated on mount\n        const checkAuth = async ()=>{\n            const token = localStorage.getItem(\"authToken\");\n            if (token) {\n                try {\n                    // First, verify the token is valid\n                    const verifyResponse = await fetch(\"\".concat(\"http://127.0.0.1:8000/\", \"/api/user/auth/token/verify/\"), {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            token\n                        })\n                    });\n                    if (!verifyResponse.ok) {\n                        console.log(\"Token invalid, status:\", verifyResponse.status);\n                        // Try to use refresh token if available\n                        const refreshToken = localStorage.getItem(\"refreshToken\");\n                        if (refreshToken) {\n                            try {\n                                const refreshResponse = await fetch(\"http://localhost:8000/api/user/auth/token/refresh/\", {\n                                    method: \"POST\",\n                                    headers: {\n                                        \"Content-Type\": \"application/json\"\n                                    },\n                                    body: JSON.stringify({\n                                        refresh: refreshToken\n                                    })\n                                });\n                                if (refreshResponse.ok) {\n                                    const refreshData = await refreshResponse.json();\n                                    localStorage.setItem(\"authToken\", refreshData.access);\n                                    // Continue with the new token\n                                    fetchUserData(refreshData.access);\n                                    return;\n                                }\n                            } catch (refreshError) {\n                                console.error(\"Token refresh failed:\", refreshError);\n                            }\n                        }\n                        // If we get here, both token verify and refresh failed\n                        localStorage.removeItem(\"authToken\");\n                        localStorage.removeItem(\"refreshToken\");\n                        setUser(null);\n                        setIsAuthenticated(false);\n                        setLoading(false);\n                        return;\n                    }\n                    // Token is valid, get user data\n                    await fetchUserData(token);\n                } catch (error) {\n                    console.error(\"Authentication check failed:\", error);\n                    localStorage.removeItem(\"authToken\");\n                    localStorage.removeItem(\"refreshToken\");\n                    setUser(null);\n                    setIsAuthenticated(false);\n                    setLoading(false);\n                }\n            } else {\n                setLoading(false);\n            }\n        };\n        const fetchUserData = async (token)=>{\n            try {\n                const response = await fetch(\"http://localhost:8000/api/user/auth/me/\", {\n                    headers: {\n                        \"Authorization\": \"Bearer \".concat(token),\n                        \"Content-Type\": \"application/json\"\n                    },\n                    credentials: \"include\"\n                });\n                if (response.ok) {\n                    const userData = await response.json();\n                    setUser({\n                        id: userData.id,\n                        name: userData.full_name || userData.name,\n                        email: userData.email\n                    });\n                    setIsAuthenticated(true);\n                    console.log(\"User authenticated successfully on page refresh\");\n                } else {\n                    console.log(\"Failed to get user data, status:\", response.status);\n                    // Token might be valid but user data fetch failed\n                    localStorage.removeItem(\"authToken\");\n                    setUser(null);\n                    setIsAuthenticated(false);\n                }\n            } catch (error) {\n                console.error(\"Authentication check failed:\", error);\n                localStorage.removeItem(\"authToken\");\n                setUser(null);\n                setIsAuthenticated(false);\n            }\n            setLoading(false);\n        };\n        checkAuth();\n    }, []);\n    const loginWithGoogle = async ()=>{\n        // Open Google OAuth popup\n        const width = 500;\n        const height = 600;\n        const left = window.screenX + (window.outerWidth - width) / 2;\n        const top = window.screenY + (window.outerHeight - height) / 2;\n        // Construct Google OAuth URL\n        const googleOAuthUrl = \"https://accounts.google.com/o/oauth2/v2/auth?\" + \"client_id=604558986475-755fbv5bvlnamnhdm3fts9ck54ujbkv4.apps.googleusercontent.com\" + \"&redirect_uri=\".concat(encodeURIComponent(\"http://localhost:3001/Authentication/google-callback\")) + \"&response_type=id_token\" + \"&scope=\".concat(encodeURIComponent(\"openid email profile\")) + \"&nonce=\".concat(Math.random().toString(36).substring(2, 15)) + \"&prompt=select_account\"; // Open the Google OAuth popup\n        const popup = window.open(googleOAuthUrl, \"Google Login\", \"width=\".concat(width, \",height=\").concat(height, \",left=\").concat(left, \",top=\").concat(top, \",toolbar=no,menubar=no,location=no,status=no\"));\n        // Create a message listener to handle the callback\n        window.addEventListener(\"message\", async (event)=>{\n            // Only accept messages from our own domain\n            if (event.origin !== window.location.origin) return;\n            if (event.data.type === \"GOOGLE_AUTH_SUCCESS\") {\n                if (popup) popup.close();\n                try {\n                    await handleGoogleCallback(event.data.token, event.data.user);\n                    router.push(\"/profile\");\n                } catch (error) {\n                    console.error(\"Google auth callback error:\", error);\n                }\n            }\n        });\n    };\n    const handleGoogleCallback = async (token, userData)=>{\n        try {\n            const response = await fetch(\"http://localhost:8000/api/user/auth/google/token/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    id_token: token,\n                    email: userData.email,\n                    full_name: userData.name\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Google authentication failed\");\n            }\n            const data = await response.json();\n            console.log(\"Google auth response:\", data);\n            // Store tokens based on what's returned\n            if (data.access) {\n                // JWT format\n                localStorage.setItem(\"authToken\", data.access);\n                if (data.refresh) {\n                    localStorage.setItem(\"refreshToken\", data.refresh);\n                }\n            } else if (data.token) {\n                // Legacy token format\n                localStorage.setItem(\"authToken\", data.token);\n            }\n            setUser({\n                id: data.user.id,\n                name: data.user.full_name,\n                email: data.user.email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Google auth error:\", error);\n            throw error;\n        }\n    };\n    const login = async (email, password)=>{\n        setLoading(true);\n        try {\n            var _data_user, _data_user1, _data_user2, _data_user3;\n            // Clear any existing tokens first\n            localStorage.removeItem(\"authToken\");\n            localStorage.removeItem(\"refreshToken\");\n            const response = await fetch(\"http://localhost:8000/api/user/auth/login/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || \"Login failed\");\n            }\n            const data = await response.json();\n            console.log(\"Login response:\", data);\n            // Store tokens - we're using JWT which returns access and refresh tokens\n            if (data.access) {\n                localStorage.setItem(\"authToken\", data.access);\n            } else if (data.token) {\n                // Fallback for non-JWT authentication\n                localStorage.setItem(\"authToken\", data.token);\n            }\n            if (data.refresh) {\n                localStorage.setItem(\"refreshToken\", data.refresh);\n            }\n            // Update user state\n            setUser({\n                id: (_data_user = data.user) === null || _data_user === void 0 ? void 0 : _data_user.id,\n                name: ((_data_user1 = data.user) === null || _data_user1 === void 0 ? void 0 : _data_user1.full_name) || ((_data_user2 = data.user) === null || _data_user2 === void 0 ? void 0 : _data_user2.name),\n                email: ((_data_user3 = data.user) === null || _data_user3 === void 0 ? void 0 : _data_user3.email) || email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        } finally{\n            setLoading(false); // Make sure loading is always set to false\n        }\n    };\n    const logout = ()=>{\n        localStorage.removeItem(\"authToken\");\n        localStorage.removeItem(\"refreshToken\");\n        setUser(null);\n        setIsAuthenticated(false);\n        // Redirect to login page\n        router.push(\"/Authentication/login\");\n    };\n    const value = {\n        user,\n        loading,\n        login,\n        logout,\n        loginWithGoogle,\n        handleGoogleCallback,\n        isAuthenticated\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\ScholarshipPortal\\\\scholarship-portal\\\\src\\\\app\\\\Authentication\\\\context\\\\AuthContext.tsx\",\n        lineNumber: 300,\n        columnNumber: 10\n    }, this);\n}\n_s(AuthProvider, \"l0f2cJVvoD9s2nghHVOe+1CbBy0=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvQXV0aGVudGljYXRpb24vY29udGV4dC9BdXRoQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFeUY7QUFDN0M7QUFnQzVDLE1BQU1NLDRCQUFjTCxvREFBYUEsQ0FBOEJNO0FBRXhELFNBQVNDLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdSLCtDQUFRQSxDQUFjO0lBQzlDLE1BQU0sQ0FBQ1MsU0FBU0MsV0FBVyxHQUFHViwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNXLGlCQUFpQkMsbUJBQW1CLEdBQUdaLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU1hLFNBQVNYLDBEQUFTQTtJQUV4QkQsZ0RBQVNBLENBQUM7UUFDUixzREFBc0Q7UUFDdEQsTUFBTWEsWUFBWTtZQUNoQixNQUFNQyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFFbkMsSUFBSUYsT0FBTztnQkFDVCxJQUFJO29CQUNGLG1DQUFtQztvQkFDbkMsTUFBTUcsaUJBQWlCLE1BQU1DLE1BQU0sR0FBbUMsT0FBaENDLHdCQUErQixFQUFDLGlDQUErQjt3QkFDbkdHLFFBQVE7d0JBQ1JDLFNBQVM7NEJBQ1AsZ0JBQWdCO3dCQUNsQjt3QkFDQUMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDOzRCQUFFWjt3QkFBTTtvQkFDL0I7b0JBRUEsSUFBSSxDQUFDRyxlQUFlVSxFQUFFLEVBQUU7d0JBQ3RCQyxRQUFRQyxHQUFHLENBQUMsMEJBQTBCWixlQUFlYSxNQUFNO3dCQUMzRCx3Q0FBd0M7d0JBQ3hDLE1BQU1DLGVBQWVoQixhQUFhQyxPQUFPLENBQUM7d0JBQzFDLElBQUllLGNBQWM7NEJBQ2hCLElBQUk7Z0NBQ0YsTUFBTUMsa0JBQWtCLE1BQU1kLE1BQU0sc0RBQXNEO29DQUN4RkksUUFBUTtvQ0FDUkMsU0FBUzt3Q0FDUCxnQkFBZ0I7b0NBQ2xCO29D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c0RBQVNBOzs7S0FKVkc7QUF5UVQsTUFBTWlGLFVBQVU7O0lBQ3JCLE1BQU1DLFVBQVV4RixpREFBVUEsQ0FBQ0k7SUFDM0IsSUFBSW9GLFlBQVluRixXQUFXO1FBQ3pCLE1BQU0sSUFBSTJFLE1BQU07SUFDbEI7SUFDQSxPQUFPUTtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9BdXRoZW50aWNhdGlvbi9jb250ZXh0L0F1dGhDb250ZXh0LnRzeD8zMTdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcclxuXHJcbmludGVyZmFjZSBVc2VyUHJvZmlsZSB7XHJcbiAgYmlvPzogc3RyaW5nO1xyXG4gIGVkdWNhdGlvbj86IHN0cmluZztcclxuICBwaG9uZV9udW1iZXI/OiBzdHJpbmc7XHJcbiAgY291bnRyeT86IHN0cmluZztcclxuICBkYXRlX29mX2JpcnRoPzogc3RyaW5nO1xyXG4gIHByb2ZpbGVfcGljdHVyZT86IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIFVzZXIge1xyXG4gIGlkPzogc3RyaW5nO1xyXG4gIG5hbWU/OiBzdHJpbmc7XHJcbiAgZW1haWw6IHN0cmluZztcclxuICBmdWxsX25hbWU/OiBzdHJpbmc7XHJcbiAgZmlyc3RfbmFtZT86IHN0cmluZztcclxuICBsYXN0X25hbWU/OiBzdHJpbmc7XHJcbiAgcHJvZmlsZT86IFVzZXJQcm9maWxlO1xyXG4gIGRhdGVfam9pbmVkPzogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcclxuICB1c2VyOiBVc2VyIHwgbnVsbDtcclxuICBsb2FkaW5nOiBib29sZWFuO1xyXG4gIGxvZ2luOiAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBsb2dvdXQ6ICgpID0+IHZvaWQ7XHJcbiAgbG9naW5XaXRoR29vZ2xlOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGhhbmRsZUdvb2dsZUNhbGxiYWNrOiAodG9rZW46IHN0cmluZywgdXNlckRhdGE6IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQXV0aFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcclxuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxVc2VyIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XHJcbiAgY29uc3QgW2lzQXV0aGVudGljYXRlZCwgc2V0SXNBdXRoZW50aWNhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIENoZWNrIGlmIHRoZSB1c2VyIGlzIGFscmVhZHkgYXV0aGVudGljYXRlZCBvbiBtb3VudFxyXG4gICAgY29uc3QgY2hlY2tBdXRoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgXHJcbiAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBGaXJzdCwgdmVyaWZ5IHRoZSB0b2tlbiBpcyB2YWxpZFxyXG4gICAgICAgICAgY29uc3QgdmVyaWZ5UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMfS9hcGkvdXNlci9hdXRoL3Rva2VuL3ZlcmlmeS9gLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0b2tlbiB9KSxcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmICghdmVyaWZ5UmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJUb2tlbiBpbnZhbGlkLCBzdGF0dXM6XCIsIHZlcmlmeVJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIC8vIFRyeSB0byB1c2UgcmVmcmVzaCB0b2tlbiBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICAgICAgICBpZiAocmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hSZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3VzZXIvYXV0aC90b2tlbi9yZWZyZXNoLycsIHtcclxuICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJlZnJlc2g6IHJlZnJlc2hUb2tlbiB9KSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaFJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hEYXRhID0gYXdhaXQgcmVmcmVzaFJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIHJlZnJlc2hEYXRhLmFjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG5ldyB0b2tlblxyXG4gICAgICAgICAgICAgICAgICBmZXRjaFVzZXJEYXRhKHJlZnJlc2hEYXRhLmFjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGNhdGNoIChyZWZyZXNoRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkOicsIHJlZnJlc2hFcnJvcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgYm90aCB0b2tlbiB2ZXJpZnkgYW5kIHJlZnJlc2ggZmFpbGVkXHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICAgICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBUb2tlbiBpcyB2YWxpZCwgZ2V0IHVzZXIgZGF0YVxyXG4gICAgICAgICAgYXdhaXQgZmV0Y2hVc2VyRGF0YSh0b2tlbik7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncmVmcmVzaFRva2VuJyk7XHJcbiAgICAgICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcclxuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgZmV0Y2hVc2VyRGF0YSA9IGFzeW5jICh0b2tlbjogc3RyaW5nKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS91c2VyL2F1dGgvbWUvJywge1xyXG4gICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICBzZXRVc2VyKHtcclxuICAgICAgICAgICAgICBpZDogdXNlckRhdGEuaWQsXHJcbiAgICAgICAgICAgICAgbmFtZTogdXNlckRhdGEuZnVsbF9uYW1lIHx8IHVzZXJEYXRhLm5hbWUsXHJcbiAgICAgICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVzZXIgYXV0aGVudGljYXRlZCBzdWNjZXNzZnVsbHkgb24gcGFnZSByZWZyZXNoXCIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gZ2V0IHVzZXIgZGF0YSwgc3RhdHVzOlwiLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICAvLyBUb2tlbiBtaWdodCBiZSB2YWxpZCBidXQgdXNlciBkYXRhIGZldGNoIGZhaWxlZFxyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICAgICAgICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICAgICAgICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgICAgICAgICAgY29uc29sZS5lcnJvcignQXV0aGVudGljYXRpb24gY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgfTtcclxuXHJcbiAgICBjaGVja0F1dGgoKTtcclxuICB9LCBbXSk7XHJcbiAgY29uc3QgbG9naW5XaXRoR29vZ2xlID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgLy8gT3BlbiBHb29nbGUgT0F1dGggcG9wdXBcclxuICAgIGNvbnN0IHdpZHRoID0gNTAwO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gNjAwO1xyXG4gICAgY29uc3QgbGVmdCA9IHdpbmRvdy5zY3JlZW5YICsgKHdpbmRvdy5vdXRlcldpZHRoIC0gd2lkdGgpIC8gMjtcclxuICAgIGNvbnN0IHRvcCA9IHdpbmRvdy5zY3JlZW5ZICsgKHdpbmRvdy5vdXRlckhlaWdodCAtIGhlaWdodCkgLyAyO1xyXG4gICAgXHJcbiAgICAvLyBDb25zdHJ1Y3QgR29vZ2xlIE9BdXRoIFVSTFxyXG4gICAgY29uc3QgZ29vZ2xlT0F1dGhVcmwgPSBgaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL28vb2F1dGgyL3YyL2F1dGg/YCArXHJcbiAgICAgIGBjbGllbnRfaWQ9NjA0NTU4OTg2NDc1LTc1NWZidjVidmxuYW1uaGRtM2Z0czljazU0dWpia3Y0LmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tYCArXHJcbiAgICAgIGAmcmVkaXJlY3RfdXJpPSR7ZW5jb2RlVVJJQ29tcG9uZW50KCdodHRwOi8vbG9jYWxob3N0OjMwMDEvQXV0aGVudGljYXRpb24vZ29vZ2xlLWNhbGxiYWNrJyl9YCArXHJcbiAgICAgIGAmcmVzcG9uc2VfdHlwZT1pZF90b2tlbmAgK1xyXG4gICAgICBgJnNjb3BlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KCdvcGVuaWQgZW1haWwgcHJvZmlsZScpfWAgK1xyXG4gICAgICBgJm5vbmNlPSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KX1gICtcclxuICAgICAgYCZwcm9tcHQ9c2VsZWN0X2FjY291bnRgOyAgICAvLyBPcGVuIHRoZSBHb29nbGUgT0F1dGggcG9wdXBcclxuICAgIGNvbnN0IHBvcHVwID0gd2luZG93Lm9wZW4oXHJcbiAgICAgIGdvb2dsZU9BdXRoVXJsLFxyXG4gICAgICAnR29vZ2xlIExvZ2luJyxcclxuICAgICAgYHdpZHRoPSR7d2lkdGh9LGhlaWdodD0ke2hlaWdodH0sbGVmdD0ke2xlZnR9LHRvcD0ke3RvcH0sdG9vbGJhcj1ubyxtZW51YmFyPW5vLGxvY2F0aW9uPW5vLHN0YXR1cz1ub2BcclxuICAgICk7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBhIG1lc3NhZ2UgbGlzdGVuZXIgdG8gaGFuZGxlIHRoZSBjYWxsYmFja1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcclxuICAgICAgLy8gT25seSBhY2NlcHQgbWVzc2FnZXMgZnJvbSBvdXIgb3duIGRvbWFpblxyXG4gICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luKSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSAnR09PR0xFX0FVVEhfU1VDQ0VTUycpIHtcclxuICAgICAgICBpZiAocG9wdXApIHBvcHVwLmNsb3NlKCk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgaGFuZGxlR29vZ2xlQ2FsbGJhY2soZXZlbnQuZGF0YS50b2tlbiwgZXZlbnQuZGF0YS51c2VyKTtcclxuICAgICAgICAgIHJvdXRlci5wdXNoKCcvcHJvZmlsZScpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdHb29nbGUgYXV0aCBjYWxsYmFjayBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgfSAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZUdvb2dsZUNhbGxiYWNrID0gYXN5bmMgKHRva2VuOiBzdHJpbmcsIHVzZXJEYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeSB7ICAgICAgLy8gRXhjaGFuZ2UgdGhlIEdvb2dsZSBhdXRoIHRva2VuIGZvciBvdXIgYXBwIEpXVFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3VzZXIvYXV0aC9nb29nbGUvdG9rZW4vJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXHJcbiAgICAgICAgICBpZF90b2tlbjogdG9rZW4sIFxyXG4gICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxyXG4gICAgICAgICAgZnVsbF9uYW1lOiB1c2VyRGF0YS5uYW1lXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdHb29nbGUgYXV0aGVudGljYXRpb24gZmFpbGVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiR29vZ2xlIGF1dGggcmVzcG9uc2U6XCIsIGRhdGEpO1xyXG4gICAgICBcclxuICAgICAgLy8gU3RvcmUgdG9rZW5zIGJhc2VkIG9uIHdoYXQncyByZXR1cm5lZFxyXG4gICAgICBpZiAoZGF0YS5hY2Nlc3MpIHtcclxuICAgICAgICAvLyBKV1QgZm9ybWF0XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGRhdGEuYWNjZXNzKTtcclxuICAgICAgICBpZiAoZGF0YS5yZWZyZXNoKSB7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmVmcmVzaFRva2VuJywgZGF0YS5yZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50b2tlbikge1xyXG4gICAgICAgIC8vIExlZ2FjeSB0b2tlbiBmb3JtYXRcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0aFRva2VuJywgZGF0YS50b2tlbik7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgIGlkOiBkYXRhLnVzZXIuaWQsXHJcbiAgICAgICAgbmFtZTogZGF0YS51c2VyLmZ1bGxfbmFtZSxcclxuICAgICAgICBlbWFpbDogZGF0YS51c2VyLmVtYWlsLFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7ICAgICAgY29uc29sZS5lcnJvcignR29vZ2xlIGF1dGggZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBsb2dpbiA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRva2VucyBmaXJzdFxyXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZyZXNoVG9rZW4nKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGkvdXNlci9hdXRoL2xvZ2luLycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgcGFzc3dvcmQgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmRldGFpbCB8fCAnTG9naW4gZmFpbGVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhcIkxvZ2luIHJlc3BvbnNlOlwiLCBkYXRhKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3JlIHRva2VucyAtIHdlJ3JlIHVzaW5nIEpXVCB3aGljaCByZXR1cm5zIGFjY2VzcyBhbmQgcmVmcmVzaCB0b2tlbnNcclxuICAgICAgaWYgKGRhdGEuYWNjZXNzKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGRhdGEuYWNjZXNzKTtcclxuICAgICAgfSBlbHNlIGlmIChkYXRhLnRva2VuKSB7XHJcbiAgICAgICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1KV1QgYXV0aGVudGljYXRpb25cclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0aFRva2VuJywgZGF0YS50b2tlbik7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChkYXRhLnJlZnJlc2gpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmVmcmVzaFRva2VuJywgZGF0YS5yZWZyZXNoKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIHVzZXIgc3RhdGVcclxuICAgICAgc2V0VXNlcih7XHJcbiAgICAgICAgaWQ6IGRhdGEudXNlcj8uaWQsXHJcbiAgICAgICAgbmFtZTogZGF0YS51c2VyPy5mdWxsX25hbWUgfHwgZGF0YS51c2VyPy5uYW1lLFxyXG4gICAgICAgIGVtYWlsOiBkYXRhLnVzZXI/LmVtYWlsIHx8IGVtYWlsLFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ2luIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTsgLy8gTWFrZSBzdXJlIGxvYWRpbmcgaXMgYWx3YXlzIHNldCB0byBmYWxzZVxyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgbG9nb3V0ID0gKCkgPT4ge1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgc2V0VXNlcihudWxsKTtcclxuICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XHJcbiAgICAvLyBSZWRpcmVjdCB0byBsb2dpbiBwYWdlXHJcbiAgICByb3V0ZXIucHVzaCgnL0F1dGhlbnRpY2F0aW9uL2xvZ2luJyk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdmFsdWUgPSB7XHJcbiAgICB1c2VyLFxyXG4gICAgbG9hZGluZyxcclxuICAgIGxvZ2luLFxyXG4gICAgbG9nb3V0LFxyXG4gICAgbG9naW5XaXRoR29vZ2xlLFxyXG4gICAgaGFuZGxlR29vZ2xlQ2FsbGJhY2ssXHJcbiAgICBpc0F1dGhlbnRpY2F0ZWQsXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIDxBdXRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PntjaGlsZHJlbn08L0F1dGhDb250ZXh0LlByb3ZpZGVyPjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKSA9PiB7XHJcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQXV0aENvbnRleHQpO1xyXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xyXG4gIH1cclxuICByZXR1cm4gY29udGV4dDtcclxufTtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJvdXRlciIsIkF1dGhDb250ZXh0IiwidW5kZWZpbmVkIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VyIiwic2V0VXNlciIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwic2V0SXNBdXRoZW50aWNhdGVkIiwicm91dGVyIiwiY2hlY2tBdXRoIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidmVyaWZ5UmVzcG9uc2UiLCJmZXRjaCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJjb25zb2xlIiwibG9nIiwic3RhdHVzIiwicmVmcmVzaFRva2VuIiwicmVmcmVzaFJlc3BvbnNlIiwicmVmcmVzaCIsInJlZnJlc2hEYXRhIiwianNvbiIsInNldEl0ZW0iLCJhY2Nlc3MiLCJmZXRjaFVzZXJEYXRhIiwicmVmcmVzaEVycm9yIiwiZXJyb3IiLCJyZW1vdmVJdGVtIiwicmVzcG9uc2UiLCJjcmVkZW50aWFscyIsInVzZXJEYXRhIiwiaWQiLCJuYW1lIiwiZnVsbF9uYW1lIiwiZW1haWwiLCJsb2dpbldpdGhHb29nbGUiLCJ3aWR0aCIsImhlaWdodCIsImxlZnQiLCJ3aW5kb3ciLCJzY3JlZW5YIiwib3V0ZXJXaWR0aCIsInRvcCIsInNjcmVlblkiLCJvdXRlckhlaWdodCIsImdvb2dsZU9BdXRoVXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwicG9wdXAiLCJvcGVuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50Iiwib3JpZ2luIiwibG9jYXRpb24iLCJkYXRhIiwidHlwZSIsImNsb3NlIiwiaGFuZGxlR29vZ2xlQ2FsbGJhY2siLCJwdXNoIiwiaWRfdG9rZW4iLCJlcnJvckRhdGEiLCJFcnJvciIsImxvZ2luIiwicGFzc3dvcmQiLCJkZXRhaWwiLCJsb2dvdXQiLCJ2YWx1ZSIsIlByb3ZpZGVyIiwidXNlQXV0aCIsImNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx\n"));

/***/ })

});