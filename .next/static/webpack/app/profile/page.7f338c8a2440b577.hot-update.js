"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/profile/page",{

/***/ "(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx":
/*!********************************************************!*\
  !*** ./src/app/Authentication/context/AuthContext.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check if the user is already authenticated on mount\n        const checkAuth = async ()=>{\n            const token = localStorage.getItem(\"authToken\");\n            if (token) {\n                try {\n                    // First, verify the token is valid\n                    const verifyResponse = await fetch(\"http://localhost:8000/api/user/auth/token/verify/\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            token\n                        })\n                    });\n                    if (!verifyResponse.ok) {\n                        console.log(\"Token invalid, status:\", verifyResponse.status);\n                        // Try to use refresh token if available\n                        const refreshToken = localStorage.getItem(\"refreshToken\");\n                        if (refreshToken) {\n                            try {\n                                const refreshResponse = await fetch(\"http://localhost:8000/api/user/auth/token/refresh/\", {\n                                    method: \"POST\",\n                                    headers: {\n                                        \"Content-Type\": \"application/json\"\n                                    },\n                                    body: JSON.stringify({\n                                        refresh: refreshToken\n                                    })\n                                });\n                                if (refreshResponse.ok) {\n                                    const refreshData = await refreshResponse.json();\n                                    localStorage.setItem(\"authToken\", refreshData.access);\n                                    // Continue with the new token\n                                    fetchUserData(refreshData.access);\n                                    return;\n                                }\n                            } catch (refreshError) {\n                                console.error(\"Token refresh failed:\", refreshError);\n                            }\n                        }\n                        // If we get here, both token verify and refresh failed\n                        localStorage.removeItem(\"authToken\");\n                        localStorage.removeItem(\"refreshToken\");\n                        setUser(null);\n                        setIsAuthenticated(false);\n                        setLoading(false);\n                        return;\n                    }\n                    // Token is valid, get user data\n                    await fetchUserData(token);\n                } catch (error) {\n                    console.error(\"Authentication check failed:\", error);\n                    localStorage.removeItem(\"authToken\");\n                    localStorage.removeItem(\"refreshToken\");\n                    setUser(null);\n                    setIsAuthenticated(false);\n                    setLoading(false);\n                }\n            } else {\n                setLoading(false);\n            }\n        };\n        const fetchUserData = async (token)=>{\n            try {\n                const response = await fetch(\"http://localhost:8000/api/user/auth/me/\", {\n                    headers: {\n                        \"Authorization\": \"Bearer \".concat(token),\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (response.ok) {\n                    const userData = await response.json();\n                    setUser({\n                        id: userData.id,\n                        name: userData.full_name || userData.name,\n                        email: userData.email\n                    });\n                    setIsAuthenticated(true);\n                    console.log(\"User authenticated successfully on page refresh\");\n                } else {\n                    console.log(\"Failed to get user data, status:\", response.status);\n                    // Token might be valid but user data fetch failed\n                    localStorage.removeItem(\"authToken\");\n                    setUser(null);\n                    setIsAuthenticated(false);\n                }\n            } catch (error) {\n                console.error(\"Authentication check failed:\", error);\n                localStorage.removeItem(\"authToken\");\n                setUser(null);\n                setIsAuthenticated(false);\n            }\n            setLoading(false);\n        };\n        checkAuth();\n    }, []);\n    const loginWithGoogle = async ()=>{\n        // Open Google OAuth popup\n        const width = 500;\n        const height = 600;\n        const left = window.screenX + (window.outerWidth - width) / 2;\n        const top = window.screenY + (window.outerHeight - height) / 2;\n        // For development, use our mock Google login page instead of real OAuth\n        // In production, you'd use the real Google OAuth endpoint\n        const popup = window.open(\"/Authentication/mock-google\", \"Google Login\", \"width=\".concat(width, \",height=\").concat(height, \",left=\").concat(left, \",top=\").concat(top));\n        // Create a message listener to handle the callback\n        window.addEventListener(\"message\", async (event)=>{\n            // Only accept messages from our own domain\n            if (event.origin !== window.location.origin) return;\n            if (event.data.type === \"GOOGLE_AUTH_SUCCESS\") {\n                if (popup) popup.close();\n                try {\n                    await handleGoogleCallback(event.data.token, event.data.user);\n                    router.push(\"/profile\");\n                } catch (error) {\n                    console.error(\"Google auth callback error:\", error);\n                }\n            }\n        });\n    };\n    const handleGoogleCallback = async (token, userData)=>{\n        try {\n            const response = await fetch(\"http://localhost:8000/api/user/auth/google/token/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    id_token: token,\n                    email: userData.email,\n                    full_name: userData.name\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Google authentication failed\");\n            }\n            const data = await response.json();\n            console.log(\"Google auth response:\", data);\n            // Store tokens based on what's returned\n            if (data.access) {\n                // JWT format\n                localStorage.setItem(\"authToken\", data.access);\n                if (data.refresh) {\n                    localStorage.setItem(\"refreshToken\", data.refresh);\n                }\n            } else if (data.token) {\n                // Legacy token format\n                localStorage.setItem(\"authToken\", data.token);\n            }\n            setUser({\n                id: data.user.id,\n                name: data.user.full_name,\n                email: data.user.email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Google auth error:\", error);\n            throw error;\n        }\n    };\n    const login = async (email, password)=>{\n        setLoading(true);\n        try {\n            var _data_user, _data_user1, _data_user2, _data_user3;\n            // Clear any existing tokens first\n            localStorage.removeItem(\"authToken\");\n            localStorage.removeItem(\"refreshToken\");\n            const response = await fetch(\"http://localhost:8000/api/user/auth/login/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || \"Login failed\");\n            }\n            const data = await response.json();\n            console.log(\"Login response:\", data);\n            // Store tokens - we're using JWT which returns access and refresh tokens\n            if (data.access) {\n                localStorage.setItem(\"authToken\", data.access);\n            } else if (data.token) {\n                // Fallback for non-JWT authentication\n                localStorage.setItem(\"authToken\", data.token);\n            }\n            if (data.refresh) {\n                localStorage.setItem(\"refreshToken\", data.refresh);\n            }\n            // Update user state\n            setUser({\n                id: (_data_user = data.user) === null || _data_user === void 0 ? void 0 : _data_user.id,\n                name: ((_data_user1 = data.user) === null || _data_user1 === void 0 ? void 0 : _data_user1.full_name) || ((_data_user2 = data.user) === null || _data_user2 === void 0 ? void 0 : _data_user2.name),\n                email: ((_data_user3 = data.user) === null || _data_user3 === void 0 ? void 0 : _data_user3.email) || email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        } finally{\n            setLoading(false); // Make sure loading is always set to false\n        }\n    };\n    const register = async (name, email, password)=>{\n        setLoading(true);\n        try {\n            // Split full name into first and last name\n            const [firstName, ...lastNameParts] = name.trim().split(\" \");\n            const lastName = lastNameParts.join(\" \");\n            const response = await fetch(\"http://localhost:8000/api/user/auth/register/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    email,\n                    password,\n                    password2: password,\n                    full_name: name,\n                    first_name: firstName,\n                    last_name: lastName || \"\" // If no last name provided, use empty string\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                const errorMessage = errorData.detail || Object.values(errorData).map((err)=>Array.isArray(err) ? err.join(\", \") : err).join(\", \");\n                throw new Error(errorMessage || \"Registration failed\");\n            }\n            const data = await response.json();\n            // Some APIs might return a token immediately after registration\n            if (data.token) {\n                var _data_user, _data_user1, _data_user2;\n                localStorage.setItem(\"authToken\", data.token);\n                setUser({\n                    id: (_data_user = data.user) === null || _data_user === void 0 ? void 0 : _data_user.id,\n                    name: ((_data_user1 = data.user) === null || _data_user1 === void 0 ? void 0 : _data_user1.name) || name,\n                    email: ((_data_user2 = data.user) === null || _data_user2 === void 0 ? void 0 : _data_user2.email) || email\n                });\n                setIsAuthenticated(true);\n            }\n        } catch (error) {\n            console.error(\"Registration error:\", error);\n            throw error;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const logout = ()=>{\n        localStorage.removeItem(\"authToken\");\n        localStorage.removeItem(\"refreshToken\");\n        setUser(null);\n        setIsAuthenticated(false);\n        // Redirect to login page\n        router.push(\"/Authentication/login\");\n    };\n    const value = {\n        user,\n        loading,\n        login,\n        register,\n        logout,\n        loginWithGoogle,\n        handleGoogleCallback,\n        isAuthenticated\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\ScholarshipPortal\\\\scholarship-portal\\\\src\\\\app\\\\Authentication\\\\context\\\\AuthContext.tsx\",\n        lineNumber: 330,\n        columnNumber: 10\n    }, this);\n}\n_s(AuthProvider, \"l0f2cJVvoD9s2nghHVOe+1CbBy0=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvQXV0aGVudGljYXRpb24vY29udGV4dC9BdXRoQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFeUY7QUFDN0M7QUFtQjVDLE1BQU1NLDRCQUFjTCxvREFBYUEsQ0FBOEJNO0FBRXhELFNBQVNDLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdSLCtDQUFRQSxDQUFjO0lBQzlDLE1BQU0sQ0FBQ1MsU0FBU0MsV0FBVyxHQUFHViwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNXLGlCQUFpQkMsbUJBQW1CLEdBQUdaLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU1hLFNBQVNYLDBEQUFTQTtJQUV4QkQsZ0RBQVNBLENBQUM7UUFDUixzREFBc0Q7UUFDdEQsTUFBTWEsWUFBWTtZQUNoQixNQUFNQyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFFbkMsSUFBSUYsT0FBTztnQkFDVCxJQUFJO29CQUNGLG1DQUFtQztvQkFDbkMsTUFBTUcsaUJBQWlCLE1BQU1DLE1BQU0scURBQXFEO3dCQUN0RkMsUUFBUTt3QkFDUkMsU0FBUzs0QkFDUCxnQkFBZ0I7d0JBQ2xCO3dCQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7NEJBQUVUO3dCQUFNO29CQUMvQjtvQkFFQSxJQUFJLENBQUNHLGVBQWVPLEVBQUUsRUFBRTt3QkFDdEJDLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJULGVBQWVVLE1BQU07d0JBQzNELHdDQUF3Qzt3QkFDeEMsTUFBTUMsZUFBZWIsYUFBYUMsT0FBTyxDQUFDO3dCQUMxQyxJQUFJWSxjQUFjOzRCQUNoQixJQUFJO2dDQUNGLE1BQU1DLGtCQUFrQixNQUFNWCxNQUFNLHNEQUFzRDtvQ0FDeEZDLFFBQVE7b0NBQ1JDLFNBQVM7d0NBQ1AsZ0JBQWdCO29DQUNsQjtvQ0FDQUMsTUFBTUMsS0FBS0MsU0FBUyxDQUFD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T0E7a0JBQVF0Rjs7Ozs7O0FBQzlDO0dBbFRnQkQ7O1FBSUNILHNEQUFTQTs7O0tBSlZHO0FBb1RULE1BQU15RixVQUFVOztJQUNyQixNQUFNQyxVQUFVaEcsaURBQVVBLENBQUNJO0lBQzNCLElBQUk0RixZQUFZM0YsV0FBVztRQUN6QixNQUFNLElBQUlrRSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT3lCO0FBQ1QsRUFBRTtJQU5XRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL0F1dGhlbnRpY2F0aW9uL2NvbnRleHQvQXV0aENvbnRleHQudHN4PzMxN2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xyXG5cclxuaW50ZXJmYWNlIFVzZXIge1xyXG4gIGlkPzogc3RyaW5nO1xyXG4gIG5hbWU/OiBzdHJpbmc7XHJcbiAgZW1haWw6IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIEF1dGhDb250ZXh0VHlwZSB7XHJcbiAgdXNlcjogVXNlciB8IG51bGw7XHJcbiAgbG9hZGluZzogYm9vbGVhbjtcclxuICBsb2dpbjogKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgcmVnaXN0ZXI6IChuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9nb3V0OiAoKSA9PiB2b2lkO1xyXG4gIGxvZ2luV2l0aEdvb2dsZTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBoYW5kbGVHb29nbGVDYWxsYmFjazogKHRva2VuOiBzdHJpbmcsIHVzZXJEYXRhOiBhbnkpID0+IFByb21pc2U8dm9pZD47XHJcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xyXG59XHJcblxyXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXV0aENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEF1dGhQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XHJcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gIGNvbnN0IFtpc0F1dGhlbnRpY2F0ZWQsIHNldElzQXV0aGVudGljYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBDaGVjayBpZiB0aGUgdXNlciBpcyBhbHJlYWR5IGF1dGhlbnRpY2F0ZWQgb24gbW91bnRcclxuICAgIGNvbnN0IGNoZWNrQXV0aCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gRmlyc3QsIHZlcmlmeSB0aGUgdG9rZW4gaXMgdmFsaWRcclxuICAgICAgICAgIGNvbnN0IHZlcmlmeVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGkvdXNlci9hdXRoL3Rva2VuL3ZlcmlmeS8nLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0b2tlbiB9KSxcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmICghdmVyaWZ5UmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJUb2tlbiBpbnZhbGlkLCBzdGF0dXM6XCIsIHZlcmlmeVJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIC8vIFRyeSB0byB1c2UgcmVmcmVzaCB0b2tlbiBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICAgICAgICBpZiAocmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hSZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3VzZXIvYXV0aC90b2tlbi9yZWZyZXNoLycsIHtcclxuICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJlZnJlc2g6IHJlZnJlc2hUb2tlbiB9KSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaFJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hEYXRhID0gYXdhaXQgcmVmcmVzaFJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIHJlZnJlc2hEYXRhLmFjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG5ldyB0b2tlblxyXG4gICAgICAgICAgICAgICAgICBmZXRjaFVzZXJEYXRhKHJlZnJlc2hEYXRhLmFjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGNhdGNoIChyZWZyZXNoRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkOicsIHJlZnJlc2hFcnJvcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgYm90aCB0b2tlbiB2ZXJpZnkgYW5kIHJlZnJlc2ggZmFpbGVkXHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICAgICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBUb2tlbiBpcyB2YWxpZCwgZ2V0IHVzZXIgZGF0YVxyXG4gICAgICAgICAgYXdhaXQgZmV0Y2hVc2VyRGF0YSh0b2tlbik7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncmVmcmVzaFRva2VuJyk7XHJcbiAgICAgICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcclxuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgZmV0Y2hVc2VyRGF0YSA9IGFzeW5jICh0b2tlbjogc3RyaW5nKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS91c2VyL2F1dGgvbWUvJywge1xyXG4gICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgICAgICAgIGlkOiB1c2VyRGF0YS5pZCxcclxuICAgICAgICAgICAgICBuYW1lOiB1c2VyRGF0YS5mdWxsX25hbWUgfHwgdXNlckRhdGEubmFtZSxcclxuICAgICAgICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBhdXRoZW50aWNhdGVkIHN1Y2Nlc3NmdWxseSBvbiBwYWdlIHJlZnJlc2hcIik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBnZXQgdXNlciBkYXRhLCBzdGF0dXM6XCIsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIC8vIFRva2VuIG1pZ2h0IGJlIHZhbGlkIGJ1dCB1c2VyIGRhdGEgZmV0Y2ggZmFpbGVkXHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgICAgICAgc2V0VXNlcihudWxsKTtcclxuICAgICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikgeyAgICAgICAgICBjb25zb2xlLmVycm9yKCdBdXRoZW50aWNhdGlvbiBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgICAgICAgc2V0VXNlcihudWxsKTtcclxuICAgICAgICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9O1xyXG5cclxuICAgIGNoZWNrQXV0aCgpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgbG9naW5XaXRoR29vZ2xlID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgLy8gT3BlbiBHb29nbGUgT0F1dGggcG9wdXBcclxuICAgIGNvbnN0IHdpZHRoID0gNTAwO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gNjAwO1xyXG4gICAgY29uc3QgbGVmdCA9IHdpbmRvdy5zY3JlZW5YICsgKHdpbmRvdy5vdXRlcldpZHRoIC0gd2lkdGgpIC8gMjtcclxuICAgIGNvbnN0IHRvcCA9IHdpbmRvdy5zY3JlZW5ZICsgKHdpbmRvdy5vdXRlckhlaWdodCAtIGhlaWdodCkgLyAyO1xyXG4gICAgXHJcbiAgICAvLyBGb3IgZGV2ZWxvcG1lbnQsIHVzZSBvdXIgbW9jayBHb29nbGUgbG9naW4gcGFnZSBpbnN0ZWFkIG9mIHJlYWwgT0F1dGhcclxuICAgIC8vIEluIHByb2R1Y3Rpb24sIHlvdSdkIHVzZSB0aGUgcmVhbCBHb29nbGUgT0F1dGggZW5kcG9pbnRcclxuICAgIGNvbnN0IHBvcHVwID0gd2luZG93Lm9wZW4oXHJcbiAgICAgICcvQXV0aGVudGljYXRpb24vbW9jay1nb29nbGUnLFxyXG4gICAgICAnR29vZ2xlIExvZ2luJyxcclxuICAgICAgYHdpZHRoPSR7d2lkdGh9LGhlaWdodD0ke2hlaWdodH0sbGVmdD0ke2xlZnR9LHRvcD0ke3RvcH1gXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgYSBtZXNzYWdlIGxpc3RlbmVyIHRvIGhhbmRsZSB0aGUgY2FsbGJhY2tcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGV2ZW50KSA9PiB7XHJcbiAgICAgIC8vIE9ubHkgYWNjZXB0IG1lc3NhZ2VzIGZyb20gb3VyIG93biBkb21haW5cclxuICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpbikgcmV0dXJuO1xyXG4gICAgICBcclxuICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0dPT0dMRV9BVVRIX1NVQ0NFU1MnKSB7XHJcbiAgICAgICAgaWYgKHBvcHVwKSBwb3B1cC5jbG9zZSgpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IGhhbmRsZUdvb2dsZUNhbGxiYWNrKGV2ZW50LmRhdGEudG9rZW4sIGV2ZW50LmRhdGEudXNlcik7XHJcbiAgICAgICAgICByb3V0ZXIucHVzaCgnL3Byb2ZpbGUnKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignR29vZ2xlIGF1dGggY2FsbGJhY2sgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgIH0gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVHb29nbGVDYWxsYmFjayA9IGFzeW5jICh0b2tlbjogc3RyaW5nLCB1c2VyRGF0YTogYW55KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICB0cnkgeyAgICAgIC8vIEV4Y2hhbmdlIHRoZSBHb29nbGUgYXV0aCB0b2tlbiBmb3Igb3VyIGFwcCBKV1RcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS91c2VyL2F1dGgvZ29vZ2xlL3Rva2VuLycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxyXG4gICAgICAgICAgaWRfdG9rZW46IHRva2VuLCBcclxuICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcclxuICAgICAgICAgIGZ1bGxfbmFtZTogdXNlckRhdGEubmFtZVxyXG4gICAgICAgIH0pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCAnR29vZ2xlIGF1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkdvb2dsZSBhdXRoIHJlc3BvbnNlOlwiLCBkYXRhKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3JlIHRva2VucyBiYXNlZCBvbiB3aGF0J3MgcmV0dXJuZWRcclxuICAgICAgaWYgKGRhdGEuYWNjZXNzKSB7XHJcbiAgICAgICAgLy8gSldUIGZvcm1hdFxyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoVG9rZW4nLCBkYXRhLmFjY2Vzcyk7XHJcbiAgICAgICAgaWYgKGRhdGEucmVmcmVzaCkge1xyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlZnJlc2hUb2tlbicsIGRhdGEucmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGRhdGEudG9rZW4pIHtcclxuICAgICAgICAvLyBMZWdhY3kgdG9rZW4gZm9ybWF0XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGRhdGEudG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBzZXRVc2VyKHtcclxuICAgICAgICBpZDogZGF0YS51c2VyLmlkLFxyXG4gICAgICAgIG5hbWU6IGRhdGEudXNlci5mdWxsX25hbWUsXHJcbiAgICAgICAgZW1haWw6IGRhdGEudXNlci5lbWFpbCxcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikgeyAgICAgIGNvbnNvbGUuZXJyb3IoJ0dvb2dsZSBhdXRoIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0b2tlbnMgZmlyc3RcclxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncmVmcmVzaFRva2VuJyk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3VzZXIvYXV0aC9sb2dpbi8nLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0xvZ2luIGZhaWxlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coXCJMb2dpbiByZXNwb25zZTpcIiwgZGF0YSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSB0b2tlbnMgLSB3ZSdyZSB1c2luZyBKV1Qgd2hpY2ggcmV0dXJucyBhY2Nlc3MgYW5kIHJlZnJlc2ggdG9rZW5zXHJcbiAgICAgIGlmIChkYXRhLmFjY2Vzcykge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoVG9rZW4nLCBkYXRhLmFjY2Vzcyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50b2tlbikge1xyXG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBub24tSldUIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGRhdGEudG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGF0YS5yZWZyZXNoKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlZnJlc2hUb2tlbicsIGRhdGEucmVmcmVzaCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSB1c2VyIHN0YXRlXHJcbiAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgIGlkOiBkYXRhLnVzZXI/LmlkLFxyXG4gICAgICAgIG5hbWU6IGRhdGEudXNlcj8uZnVsbF9uYW1lIHx8IGRhdGEudXNlcj8ubmFtZSxcclxuICAgICAgICBlbWFpbDogZGF0YS51c2VyPy5lbWFpbCB8fCBlbWFpbCxcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7IC8vIE1ha2Ugc3VyZSBsb2FkaW5nIGlzIGFsd2F5cyBzZXQgdG8gZmFsc2VcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCByZWdpc3RlciA9IGFzeW5jIChuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTcGxpdCBmdWxsIG5hbWUgaW50byBmaXJzdCBhbmQgbGFzdCBuYW1lXHJcbiAgICAgIGNvbnN0IFtmaXJzdE5hbWUsIC4uLmxhc3ROYW1lUGFydHNdID0gbmFtZS50cmltKCkuc3BsaXQoJyAnKTtcclxuICAgICAgY29uc3QgbGFzdE5hbWUgPSBsYXN0TmFtZVBhcnRzLmpvaW4oJyAnKTsgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3VzZXIvYXV0aC9yZWdpc3Rlci8nLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgZW1haWwsXHJcbiAgICAgICAgICBwYXNzd29yZCxcclxuICAgICAgICAgIHBhc3N3b3JkMjogcGFzc3dvcmQsIC8vIFBhc3N3b3JkIGNvbmZpcm1hdGlvbiByZXF1aXJlZCBieSBiYWNrZW5kXHJcbiAgICAgICAgICBmdWxsX25hbWU6IG5hbWUsXHJcbiAgICAgICAgICBmaXJzdF9uYW1lOiBmaXJzdE5hbWUsXHJcbiAgICAgICAgICBsYXN0X25hbWU6IGxhc3ROYW1lIHx8ICcnIC8vIElmIG5vIGxhc3QgbmFtZSBwcm92aWRlZCwgdXNlIGVtcHR5IHN0cmluZ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICB9KTsgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5kZXRhaWwgfHwgXHJcbiAgICAgICAgICBPYmplY3QudmFsdWVzKGVycm9yRGF0YSkubWFwKGVyciA9PiBcclxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShlcnIpID8gZXJyLmpvaW4oJywgJykgOiBlcnJcclxuICAgICAgICAgICkuam9pbignLCAnKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlIHx8ICdSZWdpc3RyYXRpb24gZmFpbGVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTb21lIEFQSXMgbWlnaHQgcmV0dXJuIGEgdG9rZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgcmVnaXN0cmF0aW9uXHJcbiAgICAgIGlmIChkYXRhLnRva2VuKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGRhdGEudG9rZW4pO1xyXG4gICAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgICAgaWQ6IGRhdGEudXNlcj8uaWQsXHJcbiAgICAgICAgICBuYW1lOiBkYXRhLnVzZXI/Lm5hbWUgfHwgbmFtZSxcclxuICAgICAgICAgIGVtYWlsOiBkYXRhLnVzZXI/LmVtYWlsIHx8IGVtYWlsLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignUmVnaXN0cmF0aW9uIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGxvZ291dCA9ICgpID0+IHtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZyZXNoVG9rZW4nKTtcclxuICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xyXG4gICAgLy8gUmVkaXJlY3QgdG8gbG9naW4gcGFnZVxyXG4gICAgcm91dGVyLnB1c2goJy9BdXRoZW50aWNhdGlvbi9sb2dpbicpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHZhbHVlID0ge1xyXG4gICAgdXNlcixcclxuICAgIGxvYWRpbmcsXHJcbiAgICBsb2dpbixcclxuICAgIHJlZ2lzdGVyLFxyXG4gICAgbG9nb3V0LFxyXG4gICAgbG9naW5XaXRoR29vZ2xlLFxyXG4gICAgaGFuZGxlR29vZ2xlQ2FsbGJhY2ssXHJcbiAgICBpc0F1dGhlbnRpY2F0ZWQsXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIDxBdXRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PntjaGlsZHJlbn08L0F1dGhDb250ZXh0LlByb3ZpZGVyPjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKSA9PiB7XHJcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQXV0aENvbnRleHQpO1xyXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xyXG4gIH1cclxuICByZXR1cm4gY29udGV4dDtcclxufTtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJvdXRlciIsIkF1dGhDb250ZXh0IiwidW5kZWZpbmVkIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VyIiwic2V0VXNlciIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwic2V0SXNBdXRoZW50aWNhdGVkIiwicm91dGVyIiwiY2hlY2tBdXRoIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidmVyaWZ5UmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiY29uc29sZSIsImxvZyIsInN0YXR1cyIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hSZXNwb25zZSIsInJlZnJlc2giLCJyZWZyZXNoRGF0YSIsImpzb24iLCJzZXRJdGVtIiwiYWNjZXNzIiwiZmV0Y2hVc2VyRGF0YSIsInJlZnJlc2hFcnJvciIsImVycm9yIiwicmVtb3ZlSXRlbSIsInJlc3BvbnNlIiwidXNlckRhdGEiLCJpZCIsIm5hbWUiLCJmdWxsX25hbWUiLCJlbWFpbCIsImxvZ2luV2l0aEdvb2dsZSIsIndpZHRoIiwiaGVpZ2h0IiwibGVmdCIsIndpbmRvdyIsInNjcmVlblgiLCJvdXRlcldpZHRoIiwidG9wIiwic2NyZWVuWSIsIm91dGVySGVpZ2h0IiwicG9wdXAiLCJvcGVuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50Iiwib3JpZ2luIiwibG9jYXRpb24iLCJkYXRhIiwidHlwZSIsImNsb3NlIiwiaGFuZGxlR29vZ2xlQ2FsbGJhY2siLCJwdXNoIiwiY3JlZGVudGlhbHMiLCJpZF90b2tlbiIsImVycm9yRGF0YSIsIkVycm9yIiwibG9naW4iLCJwYXNzd29yZCIsImRldGFpbCIsInJlZ2lzdGVyIiwiZmlyc3ROYW1lIiwibGFzdE5hbWVQYXJ0cyIsInRyaW0iLCJzcGxpdCIsImxhc3ROYW1lIiwiam9pbiIsInBhc3N3b3JkMiIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJlcnJvck1lc3NhZ2UiLCJPYmplY3QiLCJ2YWx1ZXMiLCJtYXAiLCJlcnIiLCJBcnJheSIsImlzQXJyYXkiLCJsb2dvdXQiLCJ2YWx1ZSIsIlByb3ZpZGVyIiwidXNlQXV0aCIsImNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx\n"));

/***/ })

});