"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/profile/page",{

/***/ "(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx":
/*!********************************************************!*\
  !*** ./src/app/Authentication/context/AuthContext.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check if the user is already authenticated on mount\n        const checkAuth = async ()=>{\n            const token = localStorage.getItem(\"authToken\");\n            if (token) {\n                try {\n                    const response = await fetch(\"http://localhost:8000/api/user/auth/me/\", {\n                        headers: {\n                            \"Authorization\": \"Bearer \".concat(token),\n                            \"Content-Type\": \"application/json\"\n                        },\n                        credentials: \"include\"\n                    });\n                    if (response.ok) {\n                        const userData = await response.json();\n                        setUser({\n                            id: userData.id,\n                            name: userData.full_name || userData.name,\n                            email: userData.email\n                        });\n                        setIsAuthenticated(true);\n                        console.log(\"User authenticated successfully on page refresh\");\n                    } else {\n                        console.log(\"Token validation failed, status:\", response.status);\n                        // Token is invalid, remove it\n                        localStorage.removeItem(\"authToken\");\n                        setUser(null);\n                        setIsAuthenticated(false);\n                    }\n                } catch (error) {\n                    console.error(\"Authentication check failed:\", error);\n                    localStorage.removeItem(\"authToken\");\n                    setUser(null);\n                    setIsAuthenticated(false);\n                }\n            }\n            setLoading(false);\n        };\n        checkAuth();\n    }, []);\n    const loginWithGoogle = async ()=>{\n        // Open Google OAuth popup\n        const width = 500;\n        const height = 600;\n        const left = window.screenX + (window.outerWidth - width) / 2;\n        const top = window.screenY + (window.outerHeight - height) / 2;\n        // For development, use our mock Google login page instead of real OAuth\n        // In production, you'd use the real Google OAuth endpoint\n        const popup = window.open(\"/Authentication/mock-google\", \"Google Login\", \"width=\".concat(width, \",height=\").concat(height, \",left=\").concat(left, \",top=\").concat(top));\n        // Create a message listener to handle the callback\n        window.addEventListener(\"message\", async (event)=>{\n            // Only accept messages from our own domain\n            if (event.origin !== window.location.origin) return;\n            if (event.data.type === \"GOOGLE_AUTH_SUCCESS\") {\n                if (popup) popup.close();\n                try {\n                    await handleGoogleCallback(event.data.token, event.data.user);\n                    router.push(\"/profile\");\n                } catch (error) {\n                    console.error(\"Google auth callback error:\", error);\n                }\n            }\n        });\n    };\n    const handleGoogleCallback = async (token, userData)=>{\n        try {\n            const response = await fetch(\"http://localhost:8000/api/user/auth/google/token/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    id_token: token,\n                    email: userData.email,\n                    full_name: userData.name\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Google authentication failed\");\n            }\n            const data = await response.json();\n            localStorage.setItem(\"authToken\", data.token);\n            setUser({\n                id: data.user.id,\n                name: data.user.full_name,\n                email: data.user.email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Google auth error:\", error);\n            throw error;\n        }\n    };\n    const login = async (email, password)=>{\n        setLoading(true);\n        try {\n            var _data_user, _data_user1, _data_user2;\n            // Clear any existing token first\n            localStorage.removeItem(\"authToken\");\n            const response = await fetch(\"http://localhost:8000/api/user/auth/login/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password\n                }),\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || \"Login failed\");\n            }\n            const data = await response.json();\n            // Store token\n            localStorage.setItem(\"authToken\", data.token);\n            // Update user state\n            setUser({\n                id: (_data_user = data.user) === null || _data_user === void 0 ? void 0 : _data_user.id,\n                name: (_data_user1 = data.user) === null || _data_user1 === void 0 ? void 0 : _data_user1.name,\n                email: ((_data_user2 = data.user) === null || _data_user2 === void 0 ? void 0 : _data_user2.email) || email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        } finally{\n            setLoading(false); // Make sure loading is always set to false\n        }\n    };\n    const register = async (name, email, password)=>{\n        setLoading(true);\n        try {\n            // Split full name into first and last name\n            const [firstName, ...lastNameParts] = name.trim().split(\" \");\n            const lastName = lastNameParts.join(\" \");\n            const response = await fetch(\"http://localhost:8000/api/user/auth/register/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    email,\n                    password,\n                    password2: password,\n                    full_name: name,\n                    first_name: firstName,\n                    last_name: lastName || \"\" // If no last name provided, use empty string\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                const errorMessage = errorData.detail || Object.values(errorData).map((err)=>Array.isArray(err) ? err.join(\", \") : err).join(\", \");\n                throw new Error(errorMessage || \"Registration failed\");\n            }\n            const data = await response.json();\n            // Some APIs might return a token immediately after registration\n            if (data.token) {\n                var _data_user, _data_user1, _data_user2;\n                localStorage.setItem(\"authToken\", data.token);\n                setUser({\n                    id: (_data_user = data.user) === null || _data_user === void 0 ? void 0 : _data_user.id,\n                    name: ((_data_user1 = data.user) === null || _data_user1 === void 0 ? void 0 : _data_user1.name) || name,\n                    email: ((_data_user2 = data.user) === null || _data_user2 === void 0 ? void 0 : _data_user2.email) || email\n                });\n                setIsAuthenticated(true);\n            }\n        } catch (error) {\n            console.error(\"Registration error:\", error);\n            throw error;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const logout = ()=>{\n        localStorage.removeItem(\"authToken\");\n        setUser(null);\n        setIsAuthenticated(false);\n        // Redirect to login page\n        router.push(\"/Authentication/login\");\n    };\n    const value = {\n        user,\n        loading,\n        login,\n        register,\n        logout,\n        loginWithGoogle,\n        handleGoogleCallback,\n        isAuthenticated\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\ScholarshipPortal\\\\scholarship-portal\\\\src\\\\app\\\\Authentication\\\\context\\\\AuthContext.tsx\",\n        lineNumber: 243,\n        columnNumber: 10\n    }, this);\n}\n_s(AuthProvider, \"l0f2cJVvoD9s2nghHVOe+1CbBy0=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvQXV0aGVudGljYXRpb24vY29udGV4dC9BdXRoQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFeUY7QUFDN0M7QUFtQjVDLE1BQU1NLDRCQUFjTCxvREFBYUEsQ0FBOEJNO0FBRXhELFNBQVNDLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdSLCtDQUFRQSxDQUFjO0lBQzlDLE1BQU0sQ0FBQ1MsU0FBU0MsV0FBVyxHQUFHViwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNXLGlCQUFpQkMsbUJBQW1CLEdBQUdaLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU1hLFNBQVNYLDBEQUFTQTtJQUN4QkQsZ0RBQVNBLENBQUM7UUFDUixzREFBc0Q7UUFDdEQsTUFBTWEsWUFBWTtZQUNoQixNQUFNQyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFFbkMsSUFBSUYsT0FBTztnQkFDVCxJQUFJO29CQUNGLE1BQU1HLFdBQVcsTUFBTUMsTUFBTSwyQ0FBMkM7d0JBQ3RFQyxTQUFTOzRCQUNQLGlCQUFpQixVQUFnQixPQUFOTDs0QkFDM0IsZ0JBQWdCO3dCQUNsQjt3QkFDQU0sYUFBYTtvQkFDZjtvQkFBYSxJQUFJSCxTQUFTSSxFQUFFLEVBQUU7d0JBQzVCLE1BQU1DLFdBQVcsTUFBTUwsU0FBU00sSUFBSTt3QkFDcENoQixRQUFROzRCQUNOaUIsSUFBSUYsU0FBU0UsRUFBRTs0QkFDZkMsTUFBTUgsU0FBU0ksU0FBUyxJQUFJSixTQUFTRyxJQUFJOzRCQUN6Q0UsT0FBT0wsU0FBU0ssS0FBSzt3QkFDdkI7d0JBQ0FoQixtQkFBbUI7d0JBQ25CaUIsUUFBUUMsR0FBRyxDQUFDO29CQUNkLE9BQU87d0JBQ0xELFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0NaLFNBQVNhLE1BQU07d0JBQy9ELDhCQUE4Qjt3QkFDOUJmLGFBQWFnQixV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QkFBbUI7UUFDbkIseUJBQXlCO1FBQ3pCQyxPQUFPeUMsSUFBSSxDQUFDO0lBQ2Q7SUFFQSxNQUFNOEIsUUFBUTtRQUNaN0U7UUFDQUU7UUFDQXNEO1FBQ0FHO1FBQ0FpQjtRQUNBakQ7UUFDQW1CO1FBQ0ExQztJQUNGO0lBRUEscUJBQU8sOERBQUNSLFlBQVlrRixRQUFRO1FBQUNELE9BQU9BO2tCQUFROUU7Ozs7OztBQUM5QztHQTNOZ0JEOztRQUlDSCxzREFBU0E7OztLQUpWRztBQTZOVCxNQUFNaUYsVUFBVTs7SUFDckIsTUFBTUMsVUFBVXhGLGlEQUFVQSxDQUFDSTtJQUMzQixJQUFJb0YsWUFBWW5GLFdBQVc7UUFDekIsTUFBTSxJQUFJeUQsTUFBTTtJQUNsQjtJQUNBLE9BQU8wQjtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9BdXRoZW50aWNhdGlvbi9jb250ZXh0L0F1dGhDb250ZXh0LnRzeD8zMTdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcclxuXHJcbmludGVyZmFjZSBVc2VyIHtcclxuICBpZD86IHN0cmluZztcclxuICBuYW1lPzogc3RyaW5nO1xyXG4gIGVtYWlsOiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBBdXRoQ29udGV4dFR5cGUge1xyXG4gIHVzZXI6IFVzZXIgfCBudWxsO1xyXG4gIGxvYWRpbmc6IGJvb2xlYW47XHJcbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHJlZ2lzdGVyOiAobmFtZTogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGxvZ291dDogKCkgPT4gdm9pZDtcclxuICBsb2dpbldpdGhHb29nbGU6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgaGFuZGxlR29vZ2xlQ2FsbGJhY2s6ICh0b2tlbjogc3RyaW5nLCB1c2VyRGF0YTogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcclxufVxyXG5cclxuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1dGhDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBBdXRoUHJvdmlkZXIoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSkge1xyXG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlPFVzZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICBjb25zdCBbaXNBdXRoZW50aWNhdGVkLCBzZXRJc0F1dGhlbnRpY2F0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBDaGVjayBpZiB0aGUgdXNlciBpcyBhbHJlYWR5IGF1dGhlbnRpY2F0ZWQgb24gbW91bnRcclxuICAgIGNvbnN0IGNoZWNrQXV0aCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICB0cnkgeyAgICAgICAgICAvLyBWYWxpZGF0ZSB0b2tlbiB3aXRoIHRoZSBiYWNrZW5kXHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3VzZXIvYXV0aC9tZS8nLCB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICAgIH0pOyAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgICAgICAgIGlkOiB1c2VyRGF0YS5pZCxcclxuICAgICAgICAgICAgICBuYW1lOiB1c2VyRGF0YS5mdWxsX25hbWUgfHwgdXNlckRhdGEubmFtZSxcclxuICAgICAgICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBhdXRoZW50aWNhdGVkIHN1Y2Nlc3NmdWxseSBvbiBwYWdlIHJlZnJlc2hcIik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRva2VuIHZhbGlkYXRpb24gZmFpbGVkLCBzdGF0dXM6XCIsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIC8vIFRva2VuIGlzIGludmFsaWQsIHJlbW92ZSBpdFxyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICAgICAgICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICAgICAgICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICAgICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjaGVja0F1dGgoKTtcclxuICB9LCBbXSk7ICBjb25zdCBsb2dpbldpdGhHb29nbGUgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAvLyBPcGVuIEdvb2dsZSBPQXV0aCBwb3B1cFxyXG4gICAgY29uc3Qgd2lkdGggPSA1MDA7XHJcbiAgICBjb25zdCBoZWlnaHQgPSA2MDA7XHJcbiAgICBjb25zdCBsZWZ0ID0gd2luZG93LnNjcmVlblggKyAod2luZG93Lm91dGVyV2lkdGggLSB3aWR0aCkgLyAyO1xyXG4gICAgY29uc3QgdG9wID0gd2luZG93LnNjcmVlblkgKyAod2luZG93Lm91dGVySGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XHJcbiAgICBcclxuICAgIC8vIEZvciBkZXZlbG9wbWVudCwgdXNlIG91ciBtb2NrIEdvb2dsZSBsb2dpbiBwYWdlIGluc3RlYWQgb2YgcmVhbCBPQXV0aFxyXG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91J2QgdXNlIHRoZSByZWFsIEdvb2dsZSBPQXV0aCBlbmRwb2ludFxyXG4gICAgY29uc3QgcG9wdXAgPSB3aW5kb3cub3BlbihcclxuICAgICAgJy9BdXRoZW50aWNhdGlvbi9tb2NrLWdvb2dsZScsXHJcbiAgICAgICdHb29nbGUgTG9naW4nLFxyXG4gICAgICBgd2lkdGg9JHt3aWR0aH0saGVpZ2h0PSR7aGVpZ2h0fSxsZWZ0PSR7bGVmdH0sdG9wPSR7dG9wfWBcclxuICAgICk7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBhIG1lc3NhZ2UgbGlzdGVuZXIgdG8gaGFuZGxlIHRoZSBjYWxsYmFja1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcclxuICAgICAgLy8gT25seSBhY2NlcHQgbWVzc2FnZXMgZnJvbSBvdXIgb3duIGRvbWFpblxyXG4gICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luKSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSAnR09PR0xFX0FVVEhfU1VDQ0VTUycpIHtcclxuICAgICAgICBpZiAocG9wdXApIHBvcHVwLmNsb3NlKCk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgaGFuZGxlR29vZ2xlQ2FsbGJhY2soZXZlbnQuZGF0YS50b2tlbiwgZXZlbnQuZGF0YS51c2VyKTtcclxuICAgICAgICAgIHJvdXRlci5wdXNoKCcvcHJvZmlsZScpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdHb29nbGUgYXV0aCBjYWxsYmFjayBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIGNvbnN0IGhhbmRsZUdvb2dsZUNhbGxiYWNrID0gYXN5bmMgKHRva2VuOiBzdHJpbmcsIHVzZXJEYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeSB7ICAgICAgLy8gRXhjaGFuZ2UgdGhlIEdvb2dsZSBhdXRoIHRva2VuIGZvciBvdXIgYXBwIEpXVFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3VzZXIvYXV0aC9nb29nbGUvdG9rZW4vJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXHJcbiAgICAgICAgICBpZF90b2tlbjogdG9rZW4sIFxyXG4gICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxyXG4gICAgICAgICAgZnVsbF9uYW1lOiB1c2VyRGF0YS5uYW1lXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdHb29nbGUgYXV0aGVudGljYXRpb24gZmFpbGVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIFxyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0aFRva2VuJywgZGF0YS50b2tlbik7XHJcbiAgICAgIFxyXG4gICAgICBzZXRVc2VyKHtcclxuICAgICAgICBpZDogZGF0YS51c2VyLmlkLFxyXG4gICAgICAgIG5hbWU6IGRhdGEudXNlci5mdWxsX25hbWUsXHJcbiAgICAgICAgZW1haWw6IGRhdGEudXNlci5lbWFpbCxcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdHb29nbGUgYXV0aCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH07ICBjb25zdCBsb2dpbiA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRva2VuIGZpcnN0XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGkvdXNlci9hdXRoL2xvZ2luLycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgcGFzc3dvcmQgfSksXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdMb2dpbiBmYWlsZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3JlIHRva2VuXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoVG9rZW4nLCBkYXRhLnRva2VuKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSB1c2VyIHN0YXRlXHJcbiAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgIGlkOiBkYXRhLnVzZXI/LmlkLFxyXG4gICAgICAgIG5hbWU6IGRhdGEudXNlcj8ubmFtZSxcclxuICAgICAgICBlbWFpbDogZGF0YS51c2VyPy5lbWFpbCB8fCBlbWFpbCxcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7IC8vIE1ha2Ugc3VyZSBsb2FkaW5nIGlzIGFsd2F5cyBzZXQgdG8gZmFsc2VcclxuICAgIH1cclxuICB9OyAgY29uc3QgcmVnaXN0ZXIgPSBhc3luYyAobmFtZTogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU3BsaXQgZnVsbCBuYW1lIGludG8gZmlyc3QgYW5kIGxhc3QgbmFtZVxyXG4gICAgICBjb25zdCBbZmlyc3ROYW1lLCAuLi5sYXN0TmFtZVBhcnRzXSA9IG5hbWUudHJpbSgpLnNwbGl0KCcgJyk7XHJcbiAgICAgIGNvbnN0IGxhc3ROYW1lID0gbGFzdE5hbWVQYXJ0cy5qb2luKCcgJyk7ICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS91c2VyL2F1dGgvcmVnaXN0ZXIvJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIGVtYWlsLFxyXG4gICAgICAgICAgcGFzc3dvcmQsXHJcbiAgICAgICAgICBwYXNzd29yZDI6IHBhc3N3b3JkLCAvLyBQYXNzd29yZCBjb25maXJtYXRpb24gcmVxdWlyZWQgYnkgYmFja2VuZFxyXG4gICAgICAgICAgZnVsbF9uYW1lOiBuYW1lLFxyXG4gICAgICAgICAgZmlyc3RfbmFtZTogZmlyc3ROYW1lLFxyXG4gICAgICAgICAgbGFzdF9uYW1lOiBsYXN0TmFtZSB8fCAnJyAvLyBJZiBubyBsYXN0IG5hbWUgcHJvdmlkZWQsIHVzZSBlbXB0eSBzdHJpbmdcclxuICAgICAgICB9KSxcclxuICAgICAgfSk7ICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZGV0YWlsIHx8IFxyXG4gICAgICAgICAgT2JqZWN0LnZhbHVlcyhlcnJvckRhdGEpLm1hcChlcnIgPT4gXHJcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZXJyKSA/IGVyci5qb2luKCcsICcpIDogZXJyXHJcbiAgICAgICAgICApLmpvaW4oJywgJyk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSB8fCAnUmVnaXN0cmF0aW9uIGZhaWxlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgLy8gU29tZSBBUElzIG1pZ2h0IHJldHVybiBhIHRva2VuIGltbWVkaWF0ZWx5IGFmdGVyIHJlZ2lzdHJhdGlvblxyXG4gICAgICBpZiAoZGF0YS50b2tlbikge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoVG9rZW4nLCBkYXRhLnRva2VuKTtcclxuICAgICAgICBzZXRVc2VyKHtcclxuICAgICAgICAgIGlkOiBkYXRhLnVzZXI/LmlkLFxyXG4gICAgICAgICAgbmFtZTogZGF0YS51c2VyPy5uYW1lIHx8IG5hbWUsXHJcbiAgICAgICAgICBlbWFpbDogZGF0YS51c2VyPy5lbWFpbCB8fCBlbWFpbCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlZ2lzdHJhdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbG9nb3V0ID0gKCkgPT4ge1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgc2V0VXNlcihudWxsKTtcclxuICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XHJcbiAgICAvLyBSZWRpcmVjdCB0byBsb2dpbiBwYWdlXHJcbiAgICByb3V0ZXIucHVzaCgnL0F1dGhlbnRpY2F0aW9uL2xvZ2luJyk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdmFsdWUgPSB7XHJcbiAgICB1c2VyLFxyXG4gICAgbG9hZGluZyxcclxuICAgIGxvZ2luLFxyXG4gICAgcmVnaXN0ZXIsXHJcbiAgICBsb2dvdXQsXHJcbiAgICBsb2dpbldpdGhHb29nbGUsXHJcbiAgICBoYW5kbGVHb29nbGVDYWxsYmFjayxcclxuICAgIGlzQXV0aGVudGljYXRlZCxcclxuICB9O1xyXG5cclxuICByZXR1cm4gPEF1dGhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+e2NoaWxkcmVufTwvQXV0aENvbnRleHQuUHJvdmlkZXI+O1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQXV0aCA9ICgpID0+IHtcclxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XHJcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBdXRoIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXV0aFByb3ZpZGVyJyk7XHJcbiAgfVxyXG4gIHJldHVybiBjb250ZXh0O1xyXG59O1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUm91dGVyIiwiQXV0aENvbnRleHQiLCJ1bmRlZmluZWQiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJzZXRVc2VyIiwibG9hZGluZyIsInNldExvYWRpbmciLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRJc0F1dGhlbnRpY2F0ZWQiLCJyb3V0ZXIiLCJjaGVja0F1dGgiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsImNyZWRlbnRpYWxzIiwib2siLCJ1c2VyRGF0YSIsImpzb24iLCJpZCIsIm5hbWUiLCJmdWxsX25hbWUiLCJlbWFpbCIsImNvbnNvbGUiLCJsb2ciLCJzdGF0dXMiLCJyZW1vdmVJdGVtIiwiZXJyb3IiLCJsb2dpbldpdGhHb29nbGUiLCJ3aWR0aCIsImhlaWdodCIsImxlZnQiLCJ3aW5kb3ciLCJzY3JlZW5YIiwib3V0ZXJXaWR0aCIsInRvcCIsInNjcmVlblkiLCJvdXRlckhlaWdodCIsInBvcHVwIiwib3BlbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIm9yaWdpbiIsImxvY2F0aW9uIiwiZGF0YSIsInR5cGUiLCJjbG9zZSIsImhhbmRsZUdvb2dsZUNhbGxiYWNrIiwicHVzaCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaWRfdG9rZW4iLCJlcnJvckRhdGEiLCJFcnJvciIsInNldEl0ZW0iLCJsb2dpbiIsInBhc3N3b3JkIiwiZGV0YWlsIiwicmVnaXN0ZXIiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZVBhcnRzIiwidHJpbSIsInNwbGl0IiwibGFzdE5hbWUiLCJqb2luIiwicGFzc3dvcmQyIiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImVycm9yTWVzc2FnZSIsIk9iamVjdCIsInZhbHVlcyIsIm1hcCIsImVyciIsIkFycmF5IiwiaXNBcnJheSIsImxvZ291dCIsInZhbHVlIiwiUHJvdmlkZXIiLCJ1c2VBdXRoIiwiY29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx\n"));

/***/ })

});