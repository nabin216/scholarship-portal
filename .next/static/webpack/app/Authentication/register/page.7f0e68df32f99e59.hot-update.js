"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/Authentication/register/page",{

/***/ "(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx":
/*!********************************************************!*\
  !*** ./src/app/Authentication/context/AuthContext.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check if the user is already authenticated on mount\n        const checkAuth = async ()=>{\n            const token = localStorage.getItem(\"authToken\");\n            if (token) {\n                try {\n                    const response = await fetch(\"http://localhost:8000/api/user/auth/me/\", {\n                        headers: {\n                            \"Authorization\": \"Token \".concat(token)\n                        },\n                        credentials: \"include\"\n                    });\n                    if (response.ok) {\n                        const userData = await response.json();\n                        setUser({\n                            id: userData.id,\n                            name: userData.name,\n                            email: userData.email\n                        });\n                        setIsAuthenticated(true);\n                    } else {\n                        // Token is invalid, remove it\n                        localStorage.removeItem(\"authToken\");\n                        setUser(null);\n                        setIsAuthenticated(false);\n                    }\n                } catch (error) {\n                    console.error(\"Authentication check failed:\", error);\n                    localStorage.removeItem(\"authToken\");\n                    setUser(null);\n                    setIsAuthenticated(false);\n                }\n            }\n            setLoading(false);\n        };\n        checkAuth();\n    }, []);\n    const loginWithGoogle = async ()=>{\n        // Open Google OAuth popup\n        const width = 500;\n        const height = 600;\n        const left = window.screenX + (window.outerWidth - width) / 2;\n        const top = window.screenY + (window.outerHeight - height) / 2;\n        // For development, use our mock Google login page instead of real OAuth\n        // In production, you'd use the real Google OAuth endpoint\n        const popup = window.open(\"/Authentication/mock-google\", \"Google Login\", \"width=\".concat(width, \",height=\").concat(height, \",left=\").concat(left, \",top=\").concat(top));\n        // Create a message listener to handle the callback\n        window.addEventListener(\"message\", async (event)=>{\n            // Only accept messages from our own domain\n            if (event.origin !== window.location.origin) return;\n            if (event.data.type === \"GOOGLE_AUTH_SUCCESS\") {\n                if (popup) popup.close();\n                try {\n                    await handleGoogleCallback(event.data.token, event.data.user);\n                    router.push(\"/profile\");\n                } catch (error) {\n                    console.error(\"Google auth callback error:\", error);\n                }\n            }\n        });\n    };\n    const handleGoogleCallback = async (token, userData)=>{\n        try {\n            const response = await fetch(\"http://localhost:8000/api/user/auth/google/token/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    id_token: token,\n                    email: userData.email,\n                    full_name: userData.name\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Google authentication failed\");\n            }\n            const data = await response.json();\n            localStorage.setItem(\"authToken\", data.token);\n            setUser({\n                id: data.user.id,\n                name: data.user.full_name,\n                email: data.user.email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Google auth error:\", error);\n            throw error;\n        }\n    };\n    const login = async (email, password)=>{\n        setLoading(true);\n        try {\n            var _data_user, _data_user1, _data_user2;\n            const response = await fetch(\"http://localhost:8000/api/user/auth/login/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password\n                }),\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || \"Login failed\");\n            }\n            const data = await response.json();\n            // Store token\n            localStorage.setItem(\"authToken\", data.token);\n            // Update user state\n            setUser({\n                id: (_data_user = data.user) === null || _data_user === void 0 ? void 0 : _data_user.id,\n                name: (_data_user1 = data.user) === null || _data_user1 === void 0 ? void 0 : _data_user1.name,\n                email: ((_data_user2 = data.user) === null || _data_user2 === void 0 ? void 0 : _data_user2.email) || email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        } finally{\n            setLoading(false); // Make sure loading is always set to false\n        }\n    };\n    const register = async (name, email, password)=>{\n        setLoading(true);\n        try {\n            // Split full name into first and last name\n            const [firstName, ...lastNameParts] = name.trim().split(\" \");\n            const lastName = lastNameParts.join(\" \");\n            const response = await fetch(\"http://localhost:8000/api/user/auth/register/\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password,\n                    password2: password,\n                    full_name: name,\n                    first_name: firstName,\n                    last_name: lastName || \"\" // If no last name provided, use empty string\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                const errorMessage = errorData.detail || Object.values(errorData).map((err)=>Array.isArray(err) ? err.join(\", \") : err).join(\", \");\n                throw new Error(errorMessage || \"Registration failed\");\n            }\n            const data = await response.json();\n            // Some APIs might return a token immediately after registration\n            if (data.token) {\n                var _data_user, _data_user1, _data_user2;\n                localStorage.setItem(\"authToken\", data.token);\n                setUser({\n                    id: (_data_user = data.user) === null || _data_user === void 0 ? void 0 : _data_user.id,\n                    name: ((_data_user1 = data.user) === null || _data_user1 === void 0 ? void 0 : _data_user1.name) || name,\n                    email: ((_data_user2 = data.user) === null || _data_user2 === void 0 ? void 0 : _data_user2.email) || email\n                });\n                setIsAuthenticated(true);\n            }\n        } catch (error) {\n            console.error(\"Registration error:\", error);\n            throw error;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const logout = ()=>{\n        localStorage.removeItem(\"authToken\");\n        setUser(null);\n        setIsAuthenticated(false);\n        // Redirect to login page\n        router.push(\"/Authentication/login\");\n    };\n    const value = {\n        user,\n        loading,\n        login,\n        register,\n        logout,\n        loginWithGoogle,\n        handleGoogleCallback,\n        isAuthenticated\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\ScholarshipPortal\\\\scholarship-portal\\\\src\\\\app\\\\Authentication\\\\context\\\\AuthContext.tsx\",\n        lineNumber: 241,\n        columnNumber: 10\n    }, this);\n}\n_s(AuthProvider, \"l0f2cJVvoD9s2nghHVOe+1CbBy0=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvQXV0aGVudGljYXRpb24vY29udGV4dC9BdXRoQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFeUY7QUFDN0M7QUFtQjVDLE1BQU1NLDRCQUFjTCxvREFBYUEsQ0FBOEJNO0FBRXhELFNBQVNDLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdSLCtDQUFRQSxDQUFjO0lBQzlDLE1BQU0sQ0FBQ1MsU0FBU0MsV0FBVyxHQUFHViwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNXLGlCQUFpQkMsbUJBQW1CLEdBQUdaLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU1hLFNBQVNYLDBEQUFTQTtJQUV4QkQsZ0RBQVNBLENBQUM7UUFDUixzREFBc0Q7UUFDdEQsTUFBTWEsWUFBWTtZQUNoQixNQUFNQyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFFbkMsSUFBSUYsT0FBTztnQkFDVCxJQUFJO29CQUNGLE1BQU1HLFdBQVcsTUFBTUMsTUFBTSwyQ0FBMkM7d0JBQ3RFQyxTQUFTOzRCQUNQLGlCQUFpQixTQUFlLE9BQU5MO3dCQUM1Qjt3QkFDQU0sYUFBYTtvQkFDZjtvQkFFQSxJQUFJSCxTQUFTSSxFQUFFLEVBQUU7d0JBQ2YsTUFBTUMsV0FBVyxNQUFNTCxTQUFTTSxJQUFJO3dCQUNwQ2hCLFFBQVE7NEJBQ05pQixJQUFJRixTQUFTRSxFQUFFOzRCQUNmQyxNQUFNSCxTQUFTRyxJQUFJOzRCQUNuQkMsT0FBT0osU0FBU0ksS0FBSzt3QkFDdkI7d0JBQ0FmLG1CQUFtQjtvQkFDckIsT0FBTzt3QkFDTCw4QkFBOEI7d0JBQzlCSSxhQUFhWSxVQUFVLENBQUM7d0JBQ3hCcEIsUUFBUTt3QkFDUkksbUJBQW1CO29CQUNyQjtnQkFDRixFQUFFLE9BQU9pQixPQUFPO29CQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtvQkFD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QTtrQkFBUTVFOzs7Ozs7QUFDOUM7R0F6TmdCRDs7UUFJQ0gsc0RBQVNBOzs7S0FKVkc7QUEyTlQsTUFBTStFLFVBQVU7O0lBQ3JCLE1BQU1DLFVBQVV0RixpREFBVUEsQ0FBQ0k7SUFDM0IsSUFBSWtGLFlBQVlqRixXQUFXO1FBQ3pCLE1BQU0sSUFBSXVELE1BQU07SUFDbEI7SUFDQSxPQUFPMEI7QUFDVCxFQUFFO0lBTldEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvQXV0aGVudGljYXRpb24vY29udGV4dC9BdXRoQ29udGV4dC50c3g/MzE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XHJcblxyXG5pbnRlcmZhY2UgVXNlciB7XHJcbiAgaWQ/OiBzdHJpbmc7XHJcbiAgbmFtZT86IHN0cmluZztcclxuICBlbWFpbDogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcclxuICB1c2VyOiBVc2VyIHwgbnVsbDtcclxuICBsb2FkaW5nOiBib29sZWFuO1xyXG4gIGxvZ2luOiAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICByZWdpc3RlcjogKG5hbWU6IHN0cmluZywgZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBsb2dvdXQ6ICgpID0+IHZvaWQ7XHJcbiAgbG9naW5XaXRoR29vZ2xlOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGhhbmRsZUdvb2dsZUNhbGxiYWNrOiAodG9rZW46IHN0cmluZywgdXNlckRhdGE6IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQXV0aFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcclxuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxVc2VyIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XHJcbiAgY29uc3QgW2lzQXV0aGVudGljYXRlZCwgc2V0SXNBdXRoZW50aWNhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIENoZWNrIGlmIHRoZSB1c2VyIGlzIGFscmVhZHkgYXV0aGVudGljYXRlZCBvbiBtb3VudFxyXG4gICAgY29uc3QgY2hlY2tBdXRoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgXHJcbiAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgIHRyeSB7ICAgICAgICAgIC8vIFZhbGlkYXRlIHRva2VuIHdpdGggdGhlIGJhY2tlbmRcclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGkvdXNlci9hdXRoL21lLycsIHtcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYFRva2VuICR7dG9rZW59YCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgc2V0VXNlcih7XHJcbiAgICAgICAgICAgICAgaWQ6IHVzZXJEYXRhLmlkLFxyXG4gICAgICAgICAgICAgIG5hbWU6IHVzZXJEYXRhLm5hbWUsXHJcbiAgICAgICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVG9rZW4gaXMgaW52YWxpZCwgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgICAgICAgc2V0VXNlcihudWxsKTtcclxuICAgICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignQXV0aGVudGljYXRpb24gY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNoZWNrQXV0aCgpO1xyXG4gIH0sIFtdKTsgIGNvbnN0IGxvZ2luV2l0aEdvb2dsZSA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIC8vIE9wZW4gR29vZ2xlIE9BdXRoIHBvcHVwXHJcbiAgICBjb25zdCB3aWR0aCA9IDUwMDtcclxuICAgIGNvbnN0IGhlaWdodCA9IDYwMDtcclxuICAgIGNvbnN0IGxlZnQgPSB3aW5kb3cuc2NyZWVuWCArICh3aW5kb3cub3V0ZXJXaWR0aCAtIHdpZHRoKSAvIDI7XHJcbiAgICBjb25zdCB0b3AgPSB3aW5kb3cuc2NyZWVuWSArICh3aW5kb3cub3V0ZXJIZWlnaHQgLSBoZWlnaHQpIC8gMjtcclxuICAgIFxyXG4gICAgLy8gRm9yIGRldmVsb3BtZW50LCB1c2Ugb3VyIG1vY2sgR29vZ2xlIGxvZ2luIHBhZ2UgaW5zdGVhZCBvZiByZWFsIE9BdXRoXHJcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB5b3UnZCB1c2UgdGhlIHJlYWwgR29vZ2xlIE9BdXRoIGVuZHBvaW50XHJcbiAgICBjb25zdCBwb3B1cCA9IHdpbmRvdy5vcGVuKFxyXG4gICAgICAnL0F1dGhlbnRpY2F0aW9uL21vY2stZ29vZ2xlJyxcclxuICAgICAgJ0dvb2dsZSBMb2dpbicsXHJcbiAgICAgIGB3aWR0aD0ke3dpZHRofSxoZWlnaHQ9JHtoZWlnaHR9LGxlZnQ9JHtsZWZ0fSx0b3A9JHt0b3B9YFxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGEgbWVzc2FnZSBsaXN0ZW5lciB0byBoYW5kbGUgdGhlIGNhbGxiYWNrXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChldmVudCkgPT4ge1xyXG4gICAgICAvLyBPbmx5IGFjY2VwdCBtZXNzYWdlcyBmcm9tIG91ciBvd24gZG9tYWluXHJcbiAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHJldHVybjtcclxuICAgICAgXHJcbiAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdHT09HTEVfQVVUSF9TVUNDRVNTJykge1xyXG4gICAgICAgIGlmIChwb3B1cCkgcG9wdXAuY2xvc2UoKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBoYW5kbGVHb29nbGVDYWxsYmFjayhldmVudC5kYXRhLnRva2VuLCBldmVudC5kYXRhLnVzZXIpO1xyXG4gICAgICAgICAgcm91dGVyLnB1c2goJy9wcm9maWxlJyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dvb2dsZSBhdXRoIGNhbGxiYWNrIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZUdvb2dsZUNhbGxiYWNrID0gYXN5bmMgKHRva2VuOiBzdHJpbmcsIHVzZXJEYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeSB7ICAgICAgLy8gRXhjaGFuZ2UgdGhlIEdvb2dsZSBhdXRoIHRva2VuIGZvciBvdXIgYXBwIEpXVFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3VzZXIvYXV0aC9nb29nbGUvdG9rZW4vJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxyXG4gICAgICAgICAgaWRfdG9rZW46IHRva2VuLCBcclxuICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcclxuICAgICAgICAgIGZ1bGxfbmFtZTogdXNlckRhdGEubmFtZVxyXG4gICAgICAgIH0pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCAnR29vZ2xlIGF1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGRhdGEudG9rZW4pO1xyXG4gICAgICBcclxuICAgICAgc2V0VXNlcih7XHJcbiAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcclxuICAgICAgICBuYW1lOiBkYXRhLnVzZXIuZnVsbF9uYW1lLFxyXG4gICAgICAgIGVtYWlsOiBkYXRhLnVzZXIuZW1haWwsXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignR29vZ2xlIGF1dGggZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9OyAgY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGkvdXNlci9hdXRoL2xvZ2luLycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgcGFzc3dvcmQgfSksXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdMb2dpbiBmYWlsZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3JlIHRva2VuXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoVG9rZW4nLCBkYXRhLnRva2VuKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSB1c2VyIHN0YXRlXHJcbiAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgIGlkOiBkYXRhLnVzZXI/LmlkLFxyXG4gICAgICAgIG5hbWU6IGRhdGEudXNlcj8ubmFtZSxcclxuICAgICAgICBlbWFpbDogZGF0YS51c2VyPy5lbWFpbCB8fCBlbWFpbCxcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7IC8vIE1ha2Ugc3VyZSBsb2FkaW5nIGlzIGFsd2F5cyBzZXQgdG8gZmFsc2VcclxuICAgIH1cclxuICB9OyAgY29uc3QgcmVnaXN0ZXIgPSBhc3luYyAobmFtZTogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU3BsaXQgZnVsbCBuYW1lIGludG8gZmlyc3QgYW5kIGxhc3QgbmFtZVxyXG4gICAgICBjb25zdCBbZmlyc3ROYW1lLCAuLi5sYXN0TmFtZVBhcnRzXSA9IG5hbWUudHJpbSgpLnNwbGl0KCcgJyk7XHJcbiAgICAgIGNvbnN0IGxhc3ROYW1lID0gbGFzdE5hbWVQYXJ0cy5qb2luKCcgJyk7XHJcblxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3VzZXIvYXV0aC9yZWdpc3Rlci8nLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIGVtYWlsLFxyXG4gICAgICAgICAgcGFzc3dvcmQsXHJcbiAgICAgICAgICBwYXNzd29yZDI6IHBhc3N3b3JkLCAvLyBQYXNzd29yZCBjb25maXJtYXRpb24gcmVxdWlyZWQgYnkgYmFja2VuZFxyXG4gICAgICAgICAgZnVsbF9uYW1lOiBuYW1lLFxyXG4gICAgICAgICAgZmlyc3RfbmFtZTogZmlyc3ROYW1lLFxyXG4gICAgICAgICAgbGFzdF9uYW1lOiBsYXN0TmFtZSB8fCAnJyAvLyBJZiBubyBsYXN0IG5hbWUgcHJvdmlkZWQsIHVzZSBlbXB0eSBzdHJpbmdcclxuICAgICAgICB9KSxcclxuICAgICAgfSk7ICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZGV0YWlsIHx8IFxyXG4gICAgICAgICAgT2JqZWN0LnZhbHVlcyhlcnJvckRhdGEpLm1hcChlcnIgPT4gXHJcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZXJyKSA/IGVyci5qb2luKCcsICcpIDogZXJyXHJcbiAgICAgICAgICApLmpvaW4oJywgJyk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSB8fCAnUmVnaXN0cmF0aW9uIGZhaWxlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgLy8gU29tZSBBUElzIG1pZ2h0IHJldHVybiBhIHRva2VuIGltbWVkaWF0ZWx5IGFmdGVyIHJlZ2lzdHJhdGlvblxyXG4gICAgICBpZiAoZGF0YS50b2tlbikge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoVG9rZW4nLCBkYXRhLnRva2VuKTtcclxuICAgICAgICBzZXRVc2VyKHtcclxuICAgICAgICAgIGlkOiBkYXRhLnVzZXI/LmlkLFxyXG4gICAgICAgICAgbmFtZTogZGF0YS51c2VyPy5uYW1lIHx8IG5hbWUsXHJcbiAgICAgICAgICBlbWFpbDogZGF0YS51c2VyPy5lbWFpbCB8fCBlbWFpbCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlZ2lzdHJhdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbG9nb3V0ID0gKCkgPT4ge1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgc2V0VXNlcihudWxsKTtcclxuICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XHJcbiAgICAvLyBSZWRpcmVjdCB0byBsb2dpbiBwYWdlXHJcbiAgICByb3V0ZXIucHVzaCgnL0F1dGhlbnRpY2F0aW9uL2xvZ2luJyk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdmFsdWUgPSB7XHJcbiAgICB1c2VyLFxyXG4gICAgbG9hZGluZyxcclxuICAgIGxvZ2luLFxyXG4gICAgcmVnaXN0ZXIsXHJcbiAgICBsb2dvdXQsXHJcbiAgICBsb2dpbldpdGhHb29nbGUsXHJcbiAgICBoYW5kbGVHb29nbGVDYWxsYmFjayxcclxuICAgIGlzQXV0aGVudGljYXRlZCxcclxuICB9O1xyXG5cclxuICByZXR1cm4gPEF1dGhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+e2NoaWxkcmVufTwvQXV0aENvbnRleHQuUHJvdmlkZXI+O1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQXV0aCA9ICgpID0+IHtcclxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XHJcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBdXRoIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXV0aFByb3ZpZGVyJyk7XHJcbiAgfVxyXG4gIHJldHVybiBjb250ZXh0O1xyXG59O1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUm91dGVyIiwiQXV0aENvbnRleHQiLCJ1bmRlZmluZWQiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJzZXRVc2VyIiwibG9hZGluZyIsInNldExvYWRpbmciLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRJc0F1dGhlbnRpY2F0ZWQiLCJyb3V0ZXIiLCJjaGVja0F1dGgiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsImNyZWRlbnRpYWxzIiwib2siLCJ1c2VyRGF0YSIsImpzb24iLCJpZCIsIm5hbWUiLCJlbWFpbCIsInJlbW92ZUl0ZW0iLCJlcnJvciIsImNvbnNvbGUiLCJsb2dpbldpdGhHb29nbGUiLCJ3aWR0aCIsImhlaWdodCIsImxlZnQiLCJ3aW5kb3ciLCJzY3JlZW5YIiwib3V0ZXJXaWR0aCIsInRvcCIsInNjcmVlblkiLCJvdXRlckhlaWdodCIsInBvcHVwIiwib3BlbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIm9yaWdpbiIsImxvY2F0aW9uIiwiZGF0YSIsInR5cGUiLCJjbG9zZSIsImhhbmRsZUdvb2dsZUNhbGxiYWNrIiwicHVzaCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaWRfdG9rZW4iLCJmdWxsX25hbWUiLCJlcnJvckRhdGEiLCJFcnJvciIsInNldEl0ZW0iLCJsb2dpbiIsInBhc3N3b3JkIiwiZGV0YWlsIiwicmVnaXN0ZXIiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZVBhcnRzIiwidHJpbSIsInNwbGl0IiwibGFzdE5hbWUiLCJqb2luIiwicGFzc3dvcmQyIiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImVycm9yTWVzc2FnZSIsIk9iamVjdCIsInZhbHVlcyIsIm1hcCIsImVyciIsIkFycmF5IiwiaXNBcnJheSIsImxvZ291dCIsInZhbHVlIiwiUHJvdmlkZXIiLCJ1c2VBdXRoIiwiY29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx\n"));

/***/ })

});